<?php/** Zend_Pdf_Page */require_once 'Zend/Pdf/Page.php';class Vps_Pdf_Page extends Zend_Pdf_Page{    const OPTIONS_HALIGN_LEFT     = 0;    const OPTIONS_HALIGN_RIGHT    = -1;    const OPTIONS_HALIGN_CENTER   = -2;        const OPTIONS_VALIGN_TOP      = -1;    const OPTIONS_VALIGN_BOTTOM   = -2;    const OPTIONS_VALIGN_MIDDLE   = -3;        const OPTIONS_WRAP_ENABLED     = 1;        /**     * Draw a line of text at the specified position.     *     * @param string $text     * @param float $x     * @param float $y     * @param string $charEncoding (optional) Character encoding of source text.     *   Defaults to current locale.     * @param array $options (optional) Options for how text is ouput including     *   halign, valign, wrap, wrap-indent, and wrap-pad.  If an alignment     *   is set, the positioning variables will act as offsets.     * @throws Zend_Pdf_Exception     */    public function drawText($text, $x, $y, $charEncoding = '', $options = array())    {        if (isset($options['wrap'])) {            switch ($options['wrap']) {                case self::OPTIONS_WRAP_ENABLED:                    $this->verifyFontType();                    $buffer = '';                                        if (isset($options['wrap-pad'])) {                        $wrappad = $options['wrap-pad'];                    } else {                        $wrappad = 0;                    }                                        for ($j = 0; $j < strlen($text); $j++) {                        if ($buffer == '') {                            // If the remaining text fits then don't bother trying to wrap anything                            if ($this->getTextWidth($text) <= $this->getWidth() - $x - $wrappad) {                                return $this->drawText($text, $x, $y, $charEncoding,                                                        array_diff_key($options, array('wrap'=>null)));                            }                        }                                                // Append characters onto the buffer...                        $buffer .= substr($text, $j, 1);                                                // Until we reach a space                        if (substr($buffer,-1)==' ') {                            if (isset($oldbuffer) && !empty($oldbuffer)) {                                // If the "new" buffer doesn't fit (presumably the old does), it is time to wrap                                if ($this->getTextWidth($buffer) > $this->getWidth() - $x - $wrappad) {                                    $this->drawText(trim($oldbuffer), $x, $y, $charEncoding,                                                     array_diff_key($options, array('wrap' => null)));                                    if (isset($options['wrap-indent'])) {                                        $x = $options['wrap-indent'];                                        $options = array_diff_key($options, array('wrap-indent' => null));                                    }                                    $text = substr($text, strlen($oldbuffer));                                    $j = -1;                                    $y = $y-$this->getTextHeight();                                    $buffer = '';                                }                            }                            $oldbuffer = $buffer;                        }                    }                    break;                                    default:                    break;            }        }                if (isset($options['halign'])) {	        switch ($options['halign']) {	            case self::OPTIONS_HALIGN_RIGHT:	                $this->verifyFontType();	                $x = $this->getWidth() - $this->getTextWidth($text) - $x;	                break;	                	            case self::OPTIONS_HALIGN_CENTER:	                $this->verifyFontType();	                $x = $x + ($this->getWidth() / 2) - ($this->getTextWidth($text) / 2);	                break;	                	            default:	                break;	        }        }                if (isset($options['valign'])) {	        switch ($options['valign']) {	            case self::OPTIONS_VALIGN_TOP:	                $this->verifyFontType();	                $y = $this->getHeight() - $this->getTextHeight() - $y;	                break;	                	            case self::OPTIONS_VALIGN_BOTTOM:	                $this->verifyFontType();	                $y = $this->getTextHeight() + $y;	                break;	                	            case self::OPTIONS_VALIGN_MIDDLE:	                $this->verifyFontType();	                $y = ($this->getHeight() / 2) - ($this->getTextHeight() / 2) - $y;	                break;	                	            default:	                break;	        }        }        parent::drawText($text, $x, $y, $charEncoding);                return $y;    }        /**     * Get the suggested height of text in text space     *     * @return height     */    public function getTextHeight() {        $height = $this->getFont()->getLineHeight() /                   $this->getFont()->getUnitsPerEm() *                   $this->getFontSize();                          return $height;    }        /**     * Get the assumed width of text in text space     *     * @throws Zend_Pdf_Exception     * @return width     */    public function getTextWidth($text)    {        // Create an array of ASCII values        $asciivals = array_map(create_function('$char','return ord($char);'),str_split($text));            // Convert ASCII values to glyph numbers        $glyphnums = $this->getFont()->cmap->glyphNumbersForCharacters($asciivals);            // Create an array of widths for each glyph        $glyphwidths = $this->getFont()->widthsForGlyphs($glyphnums);                // Sum the widths and convert them to text space        $width = array_sum($glyphwidths) / $this->getFont()->getUnitsPerEm() * $this->getFontSize();                return $width;    }        /**     * Verify that the currently set font is a standard type.     *     * @throws Zend_Pdf_Exception     */    private function verifyFontType() {        if ($this->getFont()->getFontType() != Zend_Pdf_Font::TYPE_STANDARD) {            throw new Zend_Pdf_Exception('Dynamic text alignment is only available with standard fonts',                                          Zend_Pdf_Exception::NOT_IMPLEMENTED);        }    }}