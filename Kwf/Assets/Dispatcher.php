<?php
class Kwf_Assets_Dispatcher
{
    static public function dispatch($url)
    {
        if (substr($url, 0, 21)=='/assets/dependencies/') {
            $out = self::getOutputForUrl($url, Kwf_Media_Output::getEncoding());
            Kwf_Media_Output::output($out);
        }
    }

    /**
     *
     * @param string Url as generated by Kwf_Assets_Package::getPackageUrls
     * @param string Kwf_Media_Output::ENCODING_*
     */
    static public function getOutputForUrl($url, $encoding)
    {
        if (substr($url, 0, 21) != '/assets/dependencies/') throw new Kwf_Exception("invalid url: '$url'");
        $url = substr($url, 21);
        if (strpos($url, '?') !== false) {
            $url = substr($url, 0, strpos($url, '?'));
        }

        if ($encoding != 'none') {
            //own cache for encoded contents, not using Kwf_Assets_Cache as we don't need to in two-level cache
            $cacheId = 'as_'.self::_getCacheIdByUrl($url).'_'.$encoding;
            $ret = Kwf_Cache_SimpleStatic::fetch($cacheId);

            if ($ret === false) {
                $ret = self::_getOutputForUrlNoEncoding($url);
                $ret['contents'] = Kwf_Media_Output::encode($ret['contents'], $encoding);
                $ret['encoding'] = $encoding;
                Kwf_Cache_SimpleStatic::add($cacheId, $ret);
            }
            return $ret;
        } else {
            return self::_getOutputForUrlNoEncoding($url);
        }
    }

    private static function _getCacheIdByUrl($url)
    {
        return str_replace(array(':', '/', '.', ','), '_', $url);
    }

    public static function getCacheIdByPackage($package, $ext, $language)
    {
        $ret = $package->getPackageUrl($ext, $language);
        if (Kwf_Setup::getBaseUrl()) $ret = substr($ret, strlen(Kwf_Setup::getBaseUrl()));
        if (substr($ret, 0, 21) != '/assets/dependencies/') throw new Kwf_Exception("invalid url: '$url'");
        $ret = substr($ret, 21);
        if (strpos($ret, '?') !== false) {
            $ret = substr($ret, 0, strpos($ret, '?'));
        }
        return self::_getCacheIdByUrl($ret);
    }

    static private function _getOutputForUrlNoEncoding($url)
    {
        $cacheId = self::_getCacheIdByUrl($url);
        $ret = Kwf_Assets_BuildCache::getInstance()->load($cacheId);
        if ($ret === false) {
            $ret = Kwf_Assets_Cache::getInstance()->load($cacheId);
        }

        if ($ret === false) {
            require_once 'Kwf/Trl.php'; //required because setup doesn't load Trl.php before dispatching assets
            $param = explode('/', $url);
            $dependencyClass = $param[0];
            $dependencyParams = $param[1];
            $language = $param[2];
            $extension = $param[3];
            if (!class_exists($dependencyClass)) {
                throw new Kwf_Exception_NotFound();
            }
            if (!is_instance_of($dependencyClass, 'Kwf_Assets_Interface_UrlResolvable')) {
                throw new Kwf_Exception("invalid dependency class");
            }
            $dependency = call_user_func(array($dependencyClass, 'fromUrlParameter'), $dependencyClass, $dependencyParams);

            $sourceMap = false;
            if (substr($extension, -4) == '.map') {
                $extension = substr($extension, 0, -4);
                $sourceMap = true;
            }
            if ($extension == 'js') $mimeType = 'text/javascript';
            else if ($extension == 'css') $mimeType = 'text/css';
            else if ($extension == 'printcss') $mimeType = 'text/css; media=print';
            else throw new Kwf_Exception_NotYetImplemented();

            if (!$sourceMap) {
                if ($dependency instanceof Kwf_Assets_Package) {
                    $contents = $dependency->getPackageContents($mimeType, $language);
                    $mtime = $dependency->getMaxMTime($mimeType);
                } else {
                    $contents = $dependency->getContents($language);
                    $mtime = $dependency->getMTime();
                }
                if ($extension == 'js') $mimeType = 'text/javascript; charset=utf-8';
                else if ($extension == 'css' || $extension == 'printcss') $mimeType = 'text/css; charset=utf8';
            } else {
                if ($dependency instanceof Kwf_Assets_Package) {
                    $contents = $dependency->getPackageContentsSourceMap($mimeType, $language);
                    $mtime = $dependency->getMaxMTime($mimeType);
                } else {
                    throw new Kwf_Exception("can't generate sourcemap for non-packages");
                }
                $mimeType = 'application/json';
            }
            $ret = array(
                'contents' => $contents,
                'mimeType' => $mimeType,
            );
            if ($mtime) $ret['mtime'] = $mtime;
            Kwf_Assets_Cache::getInstance()->save($ret, $cacheId);
            $cacheDir = 'cache';

            //save generated caches for clear-cache-watcher
            $fileName = 'cache/assets/output-cache-ids-'.$extension;
            if (!file_exists($fileName) || strpos(file_get_contents($fileName), $cacheId."\n") === false) {
                file_put_contents($fileName, $cacheId."\n", FILE_APPEND);
            }
        }

        return $ret;
    }

    /**
     * Returns a timestamp that can be used as assets version
     *
     * will be reset everytime assets cache is cleared
     */
    public static function getAssetsVersion()
    {
        $cache = Kwf_Assets_Cache::getInstance();
        $cacheId = 'assetsVersion';
        $ret = $cache->load($cacheId);
        if ($ret === false) {
            $ret = time();
            $cache->save($ret, $cacheId);
        }
        return $ret;
    }
}
